<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <!-- Importante para m√≥viles: sin zoom autom√°tico y cubriendo el notch -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
  <title>Laberinto de Amor</title>
  <style>
    :root{
      --gap: 2px;
      --pad: 10px;
      --cols: 20;
      --rows: 21;
      --cell: 40px;
    }

    *{ box-sizing: border-box; }

    body {
      margin: 0;
      background-color: #fcefee;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      /* usar unidades ‚Äúsvh‚Äù para evitar el salto por barra de URL en m√≥vil */
      min-height: 100svh;
      overflow: hidden;
    }

    #wrap {
      position: relative;
      width: 100vw;
      height: 100svh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    #game {
      position: relative;
      display: grid;
      grid-template-columns: repeat(var(--cols), var(--cell));
      grid-template-rows: repeat(var(--rows), var(--cell));
      gap: var(--gap);
      background-color: #f8e1e7;
      padding: var(--pad);
      border-radius: 20px;
      box-shadow: 0 0 25px rgba(0,0,0,0.1);
      user-select: none;
      -webkit-user-select: none;
      /* Solo el tablero bloquea gestos de scroll/zoom, no toda la p√°gina */
      touch-action: none;
      max-width: 100vw;
      max-height: 100svh;
    }

    .cell {
      width: var(--cell);
      height: var(--cell);
      background-color: #f8e1e7;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(14px, calc(var(--cell)*0.45), 22px);
      transition: transform 0.2s ease, background-color 0.3s;
      position: relative;
      overflow: hidden;
    }

    .visited { background-color: #ffe4ec; }
    .wall    { background-color: #b68aad; }

    .player { background-color: transparent; transform: scale(1.02); }
    .player-img{
      width: 80%;
      height: 80%;
      object-fit: contain;
      filter: drop-shadow(0 1px 0 rgba(0,0,0,0.1));
      animation: bounce 0.8s infinite alternate ease-in-out;
      pointer-events: none;
    }

    .end {
      background-color: transparent;
      animation: pulse 1.5s infinite ease-in-out;
      transform-origin: center;
      font-size: clamp(16px, calc(var(--cell)*0.6), 28px);
    }

    @keyframes bounce { from { transform: translateY(0);} to { transform: translateY(-6px);} }
    @keyframes pulse  { 0%{transform:scale(1)} 50%{transform:scale(1.2);opacity:.95} 100%{transform:scale(1)} }

    .sparkle {
      position: absolute;
      width: 6px; height: 6px;
      border-radius: 50%;
      background-color: #fff;
      animation: sparkleMove 0.8s ease-out forwards;
      pointer-events: none;
      z-index: 5;
    }
    @keyframes sparkleMove { to { transform: translateY(-20px) scale(0); opacity: 0; } }

    #message {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.95);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 10;
      cursor: pointer;
      padding: 16px;
    }

    #message img {
      max-width: 92vw;
      max-height: 70svh;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
      animation: fadeIn 1.2s ease;
    }

    #restart {
      margin-top: 18px;
      padding: 10px 20px;
      font-size: 18px;
      background-color: #f6d186;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      transition: background-color 0.3s;
      font-family: inherit;
    }
    #restart:hover { background-color: #e5c066; }

    @keyframes fadeIn { from { opacity: 0; transform: scale(0.96);} to { opacity: 1; transform: scale(1);} }

    .confetti { position: absolute; top: -10px; width: 8px; height: 8px; border-radius: 50%; animation: fall linear; z-index: 20; }
    @keyframes fall { to { transform: translateY(100svh) rotate(360deg); opacity: 0; } }

    #flash { position: fixed; inset: 0; background: #fff; opacity: 0; pointer-events: none; z-index: 50; animation: flashAnim 0.5s ease-out forwards; }
    @keyframes flashAnim { 0% {opacity:1} 100% {opacity:0} }

    .heart { position: absolute; font-size: 24px; opacity: .8; animation: heartFloat 3s ease-out forwards; pointer-events:none; z-index: 15; }
    @keyframes heartFloat { 0%{transform:translateY(0) scale(1)} 100%{transform:translateY(-300px) scale(1.5); opacity:0} }

    .sparkle-large { position: absolute; width: 12px; height: 12px; border-radius: 50%; background-color: #fff; opacity: .9; animation: largeSparkle 1s ease-out forwards; pointer-events:none; z-index: 5; }
    @keyframes largeSparkle { to { transform: translateY(-50px) scale(2); opacity: 0; } }
  </style>
</head>
<body>

  <div id="wrap">
    <div id="game" aria-label="Laberinto"></div>
  </div>

  <div id="message" role="dialog" aria-modal="true">
    <img id="final-card" src="cancion.png" alt="Carta de cumplea√±os" />
    <audio id="loveSong" src="De a Dos.mp3" preload="auto" playsinline></audio>
    <button id="restart">Volver</button>
  </div>

  <audio id="moveSound" src="bue.mp3" preload="auto" playsinline></audio>

  <script>
    /* ===================== MAPA ===================== */
    const map = [
      "####################",
      "#     #     #      #",
      "# ### # ### # #### #",
      "# #   #   # #    # #",
      "# # ##### # #### # #",
      "# #     # # #    # #",
      "# ##### # # # #### #",
      "#     # # # #      #",
      "##### # # # ########",
      "#   # # #        # #",
      "# # # # ####### ## #",
      "# # # #     #      #",
      "# # ##### ### ######",
      "# #     #     #    #",
      "# ### # ##### # ## #",
      "#   # #     # # ## #",
      "##### ##### # #    #",
      "#   #     #   ######",
      "######### ########E#",
      "#                  #",
      "####################"
    ];
    const cols = map[0].length;
    const rows = map.length;

    /* ===================== DOM refs ===================== */
    const game      = document.getElementById("game");
    const message   = document.getElementById("message");
    const moveSound = document.getElementById("moveSound");
    const finalCard = document.getElementById("final-card");
    const loveSong  = document.getElementById("loveSong");
    const restart   = document.getElementById("restart");

    /* ===================== Jugador ===================== */
    const PLAYER_IMG_SRC = "jugador.png"; // Cambi√° por tu archivo local
    let playerX = 1, playerY = 1;
    let visited = new Set([`${playerX},${playerY}`]);

    /* ===================== Responsive: calcular celda con pad/gap reales ===================== */
    function numbersFromComputed(value){ return parseFloat(String(value).replace('px','')) || 0; }

    function fitGridToViewport(){
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      // Tomar pad y gap REALES del grid
      const cs = getComputedStyle(game);
      const pad     = numbersFromComputed(cs.paddingLeft); // sim√©trico
      const gap     = numbersFromComputed(cs.gap);

      // espacio √∫til real dentro de la ventana
      const usableW = vw - 2*pad - (cols-1)*gap;
      const usableH = vh - 2*pad - (rows-1)*gap;

      const cellW = Math.floor(usableW / cols);
      const cellH = Math.floor(usableH / rows);
      const cell = Math.max(18, Math.min(56, Math.min(cellW, cellH)));

      document.documentElement.style.setProperty('--cell', cell + 'px');
      document.documentElement.style.setProperty('--cols', cols);
      document.documentElement.style.setProperty('--rows', rows);
    }
    window.addEventListener('resize', fitGridToViewport);
    // Llamar una vez que el DOM est√° listo y estilos aplicados
    requestAnimationFrame(fitGridToViewport);

    /* ===================== Render ===================== */
    function drawMap() {
      game.innerHTML = "";
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.x = x;
          cell.dataset.y = y;

          if (map[y][x] === "#") {
            cell.classList.add("wall");
          } else if (visited.has(`${x},${y}`)) {
            cell.classList.add("visited");
          }

          if (x === playerX && y === playerY) {
            cell.classList.add("player");
            const img = document.createElement("img");
            img.src = PLAYER_IMG_SRC;
            img.alt = "Jugador";
            img.className = "player-img";
            cell.appendChild(img);
          } else if (map[y][x] === "E") {
            cell.classList.add("end");
            cell.textContent = "üéÇ";
          }

          game.appendChild(cell);
        }
      }
    }

    function sparkAtCell(x, y) {
      const idx = y * cols + x;
      const cellEl = game.children[idx];
      if (!cellEl) return;
      const rect   = cellEl.getBoundingClientRect();
      const s = document.createElement("div");
      s.className = "sparkle";
      s.style.left = (rect.left + rect.width/2) + "px";
      s.style.top  = (rect.top  + rect.height/2) + "px";
      document.body.appendChild(s);
      setTimeout(() => s.remove(), 800);
    }

    function spawnLargeSparkles(amount) {
      for (let i = 0; i < amount; i++) {
        const ll = document.createElement("div");
        ll.className = "sparkle-large";
        ll.style.left = Math.random()*100 + "vw";
        ll.style.top  = Math.random()*100 + "vh";
        document.body.appendChild(ll);
        setTimeout(() => ll.remove(), 1000);
      }
    }

    function launchHearts(amount) {
      for (let i = 0; i < amount; i++) {
        const h = document.createElement("div");
        h.className = "heart";
        h.textContent = "‚ù§Ô∏è";
        h.style.left = Math.random()*100 + "vw";
        h.style.animationDuration = (Math.random()*2 + 2) + "s";
        document.body.appendChild(h);
        setTimeout(() => h.remove(), 3000);
      }
    }

    function flashScreen() {
      const f = document.createElement("div");
      f.id = "flash";
      document.body.appendChild(f);
      setTimeout(() => f.remove(), 500);
    }

    /* ===================== AUDIO (WebAudio + pool HTMLAudio) ===================== */
    let audioCtx = null;
    let moveArrayBuffer = null;
    let moveBuffer = null;        // AudioBuffer decodificado
    let audioUnlocked = false;
    const activeSources = [];
    const MAX_CONCURRENT = 10;

    // --- Pool HTMLAudio para m√≥vil ---
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    const POOL_SIZE = 8;
    let audioPool = [];
    let poolReady = false;

    function createAudioPool() {
      const src = moveSound.currentSrc || moveSound.src;
      audioPool = Array.from({length: POOL_SIZE}, () => {
        const a = new Audio(src);
        a.preload = 'auto';
        a.playsInline = true;
        a.crossOrigin = moveSound.crossOrigin || null;
        return a;
      });
    }

    async function warmupAudioPool() {
      if (poolReady) return;
      if (audioPool.length === 0) createAudioPool();
      for (const a of audioPool) {
        try {
          a.muted = true;
          await a.play();
          a.pause();
          a.currentTime = 0;
          a.muted = false;
        } catch (_) {}
      }
      poolReady = true;
    }

    function playFromPool() {
      if (!poolReady || audioPool.length === 0) return false;
      const a = audioPool.find(x => x.paused || x.ended);
      if (!a) return false;
      try { a.currentTime = 0; } catch(_) {}
      a.play().catch(()=>{});
      return true;
    }

    (async function prefetchMove(){
      try {
        // Asegurar carga del elemento <audio> aunque estemos en file://
        moveSound.load();
        moveSound.volume = 1.0;
        const url = moveSound.currentSrc || moveSound.src;
        if (url && location.protocol.startsWith('http')) {
          const res = await fetch(url, { cache: "force-cache" });
          moveArrayBuffer = await res.arrayBuffer();
        }
      } catch(e) { /* fallback al <audio> */ }
    })();

    async function unlockAudio(){
      if (audioUnlocked) return;
      audioUnlocked = true;
      try {
        audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)({ latencyHint: "interactive" });
        if (audioCtx.state !== "running") { await audioCtx.resume(); }
        // ping silencioso
        const b = audioCtx.createBuffer(1, 1, 22050);
        const s = audioCtx.createBufferSource(); s.buffer = b;
        const g = audioCtx.createGain(); g.gain.value = 0.0;
        s.connect(g); g.connect(audioCtx.destination);
        try { s.start(0); } catch(_) {}

        // desbloquear <audio> fallback
        moveSound.muted = true;
        try { await moveSound.play(); } catch(_) {}
        try { moveSound.pause(); moveSound.currentTime = 0; } catch(_) {}
        moveSound.muted = false;

        if (moveArrayBuffer && !moveBuffer) {
          try { moveBuffer = await audioCtx.decodeAudioData(moveArrayBuffer.slice(0)); } catch(_) {}
        }
      } catch(e) {}
    }

    // Desbloqueo agresivo: primer gesto tambi√©n calienta el pool HTMLAudio
    ["pointerdown","touchstart","click"].forEach(ev=>{
      const opts = { once: true, passive: true };
      document.addEventListener(ev, async () => {
        await unlockAudio();
        await warmupAudioPool();
      }, opts);
      game.addEventListener(ev, async () => {
        await unlockAudio();
        await warmupAudioPool();
      }, opts);
    });

    async function playMove() {
      // 1) En m√≥vil, primero intentamos el pool HTMLAudio (muy fiable con gestos r√°pidos)
      if (isMobile && playFromPool()) return;

      // 2) WebAudio si est√° listo (salta switch silencioso en iOS)
      await unlockAudio();
      if (audioCtx && moveBuffer) {
        try { if (audioCtx.state !== "running") await audioCtx.resume(); } catch(_) {}
        const src = audioCtx.createBufferSource();
        src.buffer = moveBuffer;
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(1.0, audioCtx.currentTime + 0.004);
        const dur = moveBuffer.duration;
        g.gain.setValueAtTime(1.0, audioCtx.currentTime + Math.max(0, dur - 0.03));
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
        src.connect(g); g.connect(audioCtx.destination);
        src.start(0);

        activeSources.push(src);
        src.onended = () => {
          const i = activeSources.indexOf(src);
          if (i >= 0) activeSources.splice(i, 1);
        };
        if (activeSources.length > MAX_CONCURRENT) {
          try { activeSources.shift().stop(0); } catch(_) {}
        }
        return;
      }

      // 3) √öltimo recurso: clonar el <audio> original
      try {
        const a = moveSound.cloneNode(true);
        a.playsInline = true;
        a.currentTime = 0;
        await a.play();
        a.onended = ()=> a.remove();
      } catch(_){}
    }

    function stopAllMoveSounds() {
      while (activeSources.length) {
        const s = activeSources.pop();
        try { s.stop(0); } catch(_) {}
      }
      try { moveSound.pause(); } catch(_) {}
    }

    /* ===================== Movimiento ===================== */
    let animatingPath = false;

    function movePlayer(dx, dy) {
      if (message.style.display === "flex" || animatingPath) return;
      const newX = playerX + dx, newY = playerY + dy;
      const nextCell = map[newY]?.[newX];
      if (nextCell === " " || nextCell === "E") {
        playerX = newX; playerY = newY;
        visited.add(`${newX},${newY}`);
        drawMap();
        playMove();
        sparkAtCell(newX, newY);
      }
      if (nextCell === "E") {
        setTimeout(winSequence, 300);
      }
    }

    function winSequence() {
      message.style.display = "flex";
      flashScreen();
      launchConfetti(200);
      spawnLargeSparkles(100);
      launchHearts(80);
      stopAllMoveSounds();
    }

    /* ===================== Teclado (PC) ===================== */
    document.addEventListener("keydown", e => {
      if (message.style.display === "flex" || animatingPath) return;
      switch (e.key) {
        case "ArrowUp": case "w": case "W": movePlayer(0,-1); break;
        case "ArrowDown": case "s": case "S": movePlayer(0,1); break;
        case "ArrowLeft": case "a": case "A": movePlayer(-1,0); break;
        case "ArrowRight": case "d": case "D": movePlayer(1,0); break;
      }
    });

    /* ===================== Swipe (m√≥vil) ===================== */
    let swipeStartX=0, swipeStartY=0, swiping=false;
    const SWIPE_THRESHOLD = 22;
    game.addEventListener('touchstart', (e)=>{
      if (message.style.display === "flex" || animatingPath) return;
      if (!e.touches || e.touches.length!==1) return;
      swiping = true;
      swipeStartX = e.touches[0].clientX;
      swipeStartY = e.touches[0].clientY;
    }, {passive:true});

    game.addEventListener('touchend', (e)=>{
      if (!swiping || animatingPath) return;
      swiping = false;
      const t = e.changedTouches && e.changedTouches[0];
      if (!t) return;
      const dx = t.clientX - swipeStartX;
      const dy = t.clientY - swipeStartY;
      if (Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) return;
      if (Math.abs(dx) > Math.abs(dy)) movePlayer(dx>0?1:-1, 0);
      else movePlayer(0, dy>0?1:-1);
    }, {passive:true});

    /* ===================== Tap y arrastre preciso ===================== */
    game.addEventListener('click', onCellTap, {passive:false});

    function onCellTap(e){
      if (message.style.display === "flex" || animatingPath) return;
      const cell = e.target.closest('.cell');
      if (!cell) return;
      const tx = +cell.dataset.x, ty = +cell.dataset.y;
      goToCell(tx, ty);
    }

    function goToCell(tx, ty){
      const target = map[ty]?.[tx];
      if (!target || target === '#') return;
      const manhattan = Math.abs(tx - playerX) + Math.abs(ty - playerY);
      if (manhattan === 1) { movePlayer(tx - playerX, ty - playerY); return; }
      if (target === ' ' || target === 'E') {
        const path = findPath(playerX, playerY, tx, ty);
        if (path && path.length > 1) animatePath(path);
      }
    }

    // Arrastre: seguir celdas bajo el dedo (con pad/gap reales)
    let dragActive = false;
    let lastStepTime = 0;
    const STEP_MS = 80;

    game.addEventListener("pointerdown", (e)=>{
      if (message.style.display === "flex") return;
      dragActive = true;
      handlePointer(e);
    }, {passive:false});
    game.addEventListener("pointermove", (e)=>{
      if (!dragActive || animatingPath) return;
      handlePointer(e);
    }, {passive:false});
    game.addEventListener("pointerup", ()=>{ dragActive = false; }, {passive:true});
    game.addEventListener("pointercancel", ()=>{ dragActive = false; }, {passive:true});

    function handlePointer(e){
      e.preventDefault();
      const now = performance.now();
      if (now - lastStepTime < STEP_MS) return;
      lastStepTime = now;

      const rect = game.getBoundingClientRect();
      const cs = getComputedStyle(game);
      const pad = numbersFromComputed(cs.paddingLeft);
      const gap = numbersFromComputed(cs.gap);
      const cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell'));

      // Coordenadas relativas AL √ÅREA INTERIOR (excluyendo padding)
      const xIn = Math.min(Math.max(0, e.clientX - rect.left - pad), rect.width  - 2*pad);
      const yIn = Math.min(Math.max(0, e.clientY - rect.top  - pad), rect.height - 2*pad);

      // √≠ndice de columna/fila usando celda + gap reales
      const col = Math.min(cols-1, Math.max(0, Math.floor(xIn / (cellSize + gap))));
      const row = Math.min(rows-1, Math.max(0, Math.floor(yIn / (cellSize + gap))));

      const dx = Math.sign(col - playerX);
      const dy = Math.sign(row - playerY);
      if (Math.abs(col - playerX) + Math.abs(row - playerY) === 1) {
        movePlayer(dx, dy);
      }
    }

    // BFS
    function findPath(sx, sy, ex, ey){
      const q = [];
      const seen = new Set([`${sx},${sy}`]);
      const parent = new Map();
      q.push([sx, sy]);

      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

      while (q.length){
        const [x, y] = q.shift();
        if (x === ex && y === ey) break;
        for (const [dx, dy] of dirs){
          const nx = x + dx, ny = y + dy;
          const key = `${nx},${ny}`;
          const cell = map[ny]?.[nx];
          if (!cell || cell === '#') continue;
          if (!seen.has(key)){
            seen.add(key);
            parent.set(key, [x,y]);
            q.push([nx, ny]);
          }
        }
      }

      if (!parent.has(`${ex,ey}`) && !(sx===ex && sy===ey)) return null;

      const path = [[ex,ey]];
      let cur = [ex,ey];
      while (!(cur[0]===sx && cur[1]===sy)){
        const p = parent.get(`${cur[0]},${cur[1]}`);
        if (!p) break;
        path.push(p);
        cur = p;
      }
      path.reverse();
      return path;
    }

    function animatePath(path){
      if (!path || path.length < 2) return;
      animatingPath = true;
      let i = 1;
      const step = ()=>{
        if (i >= path.length) { animatingPath = false; return; }
        const [nx, ny] = path[i];
        const dx = Math.sign(nx - playerX);
        const dy = Math.sign(ny - playerY);
        movePlayer(dx, dy);
        i++;
        if (map[ny][nx] === 'E'){ animatingPath = false; return; }
        setTimeout(step, 80);
      };
      step();
    }

    /* ===================== Confetti / M√∫sica / Reset ===================== */
    function launchConfetti(amount) {
      for (let i = 0; i < amount; i++) {
        const c = document.createElement("div");
        c.className = "confetti";
        c.style.left = Math.random()*100+"vw";
        c.style.backgroundColor = randomPastel();
        c.style.animationDuration = (Math.random()*2+2)+"s";
        document.body.appendChild(c);
        setTimeout(() => c.remove(), 4000);
      }
    }
    function randomPastel() {
      const colors = ["#f8a5c2","#f6d186","#d3c0f9","#a8d5ba","#f5cd79","#e77f67"];
      return colors[Math.floor(Math.random()*colors.length)];
    }

    finalCard.addEventListener("click", () => {
      if (loveSong.paused) loveSong.play(); else loveSong.pause();
    });

    restart.addEventListener("click", () => {
      playerX = 1;
      playerY = 1;
      visited = new Set([`${playerX},${playerY}`]);
      loveSong.pause();
      loveSong.currentTime = 0;
      message.style.display = "none";
      fitGridToViewport();
      drawMap();
    });

    /* ===================== Start ===================== */
    drawMap();
  </script>
</body>
</html>
